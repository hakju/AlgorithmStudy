맨 먼저 size

0으로 초기화 해놓고 팝할때마다 -1 푸시할때마다 +1 해주면됨
***
그 다음 empty

back == front 여야 하지만 내 코드에서는 덱이 가득찰 경우도 back == front 라서 size ==0 조건추가
***
그 다음 front

내 덱에서 front는 마지막으로 값이 입력된 지점을 가리키고 있음
size ==0이면 -1 출력하고 아니면 배열의 a[front] 출력
***
그 다음 back

내 덱에서 back은 마지막으로 값이 입력된 다음칸을 가리키고 있음
그래서 size가 0이 아니면 a[back - 1]을 출력하면됨
그러나 back이 0을 가리키고 있고 비어있지도 않다면 배열 맨뒤 값이 back의 값임
***
그 다음 pop_front

size == 0 이면 -1 출력해주고
아닐경우 a[front] 값을 출력해준뒤 프론트를 한칸 플러스 해줘야 하는데 이때 배열을 넘어설 수 있으니 배열의 크기로 나머지연산을 시켜서 front 에 대입
후 size--;
***
그 다음 pop_back

size == 0 이면 -1 출력해주고
아닐경우 size -- ;  미리 해주고 back이 0을 가리키는지 확인.
0을 가리키고 있으면 맨 마지막칸을 pop 해야한다 그래서 a[배열크기 - 1] 출력하고 back = 배열크기 -10을 가리키고 있지 않으면 그냥 a[back -1] 하고 back--;
***
push는 기본적으로 size++; 추가
***
push_back이나 push_front가 find되면 cin<<push (int 형) 으로 숫자를 입력 받음
(cin이 공백을 기준으로 나뉘기 때문에 굳이 공백포함 입력받아서 문자열을 자르지 않아도되더라)
push back이면 a[back]에 push 하고 back에 1을 더해주면 되는데 배열을 넘어설 수 있기 때문에 N으로 나머지연산한 값을 back 에 대입

push front일 때 front가 0이면 사실상 배열 맨뒤 값에 푸시해주는거고 front 도 맨뒤칸을 가리키게 배열크기 - 1 을 대입
front 가 0 이 아니라면 한칸 마이너스 해주고 그 자리에 푸시.
