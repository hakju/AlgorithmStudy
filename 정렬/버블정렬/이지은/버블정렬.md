# 버블정렬

비교 하려는 대상의 숫자와 **`인접한 숫자`** 를 비교해나간다.

0 번째 부터 n 번째 까지 인접한 두 숫자를 비교해서 큰 숫자는 오른쪽에, 작은 숫자는 왼쪽에 배치해준다. (오름차순)

인접한 두 값을 비교하기 때문에 보글보글 거리는것이 거품 같아서 버블정렬이라고 이름을 붙힌 것 같다..

## 비교 순서

~~~
* 첫 번째 반복
0, 1 인덱스 비교
1, 2 인덱스 비교
2, 3 인덱스 비교
...
n-1, n 인덱스 비교
-> 첫 번째 반복이 끝나면 가장 큰 숫자가 n 인덱스로 이동하게 된다.
-> 마지막 숫자는 가장 큰 숫자가 뒤로 갔기 때문에, 다음 반복 시 n-1까지만 비교해주어도 된다.
~~~

~~~
* 두 번째 반복
0, 1 인덱스 비교
1, 2 인덱스 비교
2, 3 인덱스 비교
....
n-2, n-1 인덱스 비교
-> 두 번째 반복이 끝나면 두번째로 큰 숫자가 n-1 인덱스로 이동하게 된다.
~~~

## 코드
```py
def bubble():
    for i in range(N-1): # ①
        for j in range(N - i - 1): # ②
            if arr[j] > arr[j + 1]: # ③
                arr[j], arr[j + 1] = arr[j + 1], arr[j] # ④
```

- ① : range(N-1)에서 N-1인 이유는, N의 경우 마지막 순회 때 자기 자신과 혼자 비교하기 때문에 불필요한 반복이 된다. N-1을 해주어 마지막의 불필요한 반복을 제외해준다.
- ② : 첫번째 순회가 끝나면, 뒤(N-1 인덱스)에서 부터 큰 값이 채워지는 것으로 끝나므로 마지막 인덱스는 비교해줄 필요가 없다. 때문에 `매 순회`가 끝나면 `순회한 만큼` 배열의 크기를 줄여줘도 된다. `-1`을해준 이유는, `j`는 `j+1`과 비교해주기 때문에 마지막 순서에서 불필요한 반복임과 동시에 배열의 인덱스를 벗어나기 때문이다.
- ③ : 오른쪽값이 왼쪽 값보다 큰 경우를 체크해주는데 `내림차순 정렬`을 원할 경우 반대로 비교해주면 된다.
- ④ : 조건문에 해당하는 경우 두 값을 `스왑`해준다.